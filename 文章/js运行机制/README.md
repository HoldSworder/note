# js运行机制

[前端部署](https://juejin.cn/post/7017710911443959839)
[js运行机制](https://segmentfault.com/a/1190000012925872)

## 强缓存和协商缓存

### 协商缓存

表示资源未发生变更、可以使用浏览器缓存

一般会根据请求的header的一些参数判断是否命中 命中则返回304通知浏览器读取缓存

* 服务端设置Last-Modifed、Etag等实现
* 状态码为304

### 强缓存

不询问服务器 直接读取本地缓存 减少一道询问请求

* 设置Cache-Control:max-age、Expires等
* 状态码200

## 缓存更新

当缓存尚未过期 又需要更新时 可以带上版本号强制更新

使用消息摘要算法 精确到单个文件

## 进程和线程

* 线程在进程内运行
* 一个进程内可以有很多线程

### 浏览器常驻线程

* GUI渲染线程
* js引擎线程
* 事件触发线程
* 定时触发器线程
* 异步http请求线程
  
其中GUI线程和JS线程是互斥的

## 渲染步骤

1. 解析html建立dom树
2. 解析css构建render树（将css代码解析成树形的数据结构，然后结合DOM合并成render树）
3. 布局render树（layout/reflow），负责各元素尺寸、位置的计算
4. 绘制render树（paint），绘制页面像素信息
5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

## 关于硬件加速

浏览器渲染的图层分为 普通图层和复合图层

浏览器中所有文档流是一个默认复合层

只有复合图层会触发硬件加速

将元素变成复合图层的方法有

* 最常用的方式：translate3d、translateZ
* opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
* will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）
* video、iframe、canvas、webgl等元素
* 其它，譬如以前的flash插件

## 关于事件循环

* JS分为同步任务和异步任务
* 同步任务都在主线程上执行，形成一个执行栈
* 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
* 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

![事件队列](./事件队列.png)

![事件循环](./事件循环.png)

上图大致描述就是：

* 主线程运行时会产生执行栈，
* 栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）

而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调

* 如此循环
* 注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件
